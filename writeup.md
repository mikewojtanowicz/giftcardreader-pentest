# mw5046AppSec
# Michael Wojtanowicz

# BUGS

The road to debugging this program was long and painful. I initially started on an M1 processor, and the lack of x86 architecture made it incredibly difficult to properly utilize the various libraries recommended throughout this lab. The gdb debugger was especially difficult to utilize, and I spent hours upon hours troubleshooting possible fixes. This issue was consistent across the parts. When attempting to put together a coverage suite, troubleshooting lcov also proved difficult. At a far later point, I switched back to an x86 MacBook, and ran into more issues on its manual use, and with configurations in VScode. I resorted to an online gdb debugger (onlinegdb.com). From there, I was able to appropriately analyze the flow of giftcardreader.c against the examplefile and some test cases that I believed could break some of the functions. In this way, I was able to trace the values of variables across logic, and identify where certain variables would contain NULL. There was no prevention in various functions of a NULL value appearing in the logic. I was able to identify this in both my crash tests and in my fuzzer generated tests. The first NULL value I noticed was in ptr when it fails within fread(). I tried implementing conditionals to return 0 if a NULL value was picked up, but this wasn't consistent across my test. I also noticed a NULL value in thisone within the main() function. Here, I also could not get a conditional to reconcile it. However, my testing and debugging in identifying specific test cases that crashed the program. I was able to hang the program, as there are various cases within the animate() function that allow this bug to thrive. It appeared that if you managed to keep PC below 256, the while loop would never end. My assumption here was that a check on arg1 would have potentially prevented this bug from occurring, but I was met with many roadblocks here. The incrementation of PC by 3 was what led me to this idea. Alongside by lackluster experience in C, manipulating hexadecimal for the first time was a interesting experience.

# TESTING

Coverage also proved challenging in a variety of ways as I began to develop a test suite to utilize against the reader. the afl-fuzzer generated a myriad of duplicates, with many that did not prove crashes or hangs altogether. However, with a diverse set of test cases, as I was to acheive higher coverage as more code and logic flow was tested. Afl-fuzzer was incredibly difficult to set up outright, as I began this assignment outside of x86 architecture. Unfortunately, I was unable to identify direct fixes to the genuine bugs produced by the fuzzer.

Overall, I really did enjoy the assignment. I found it incredibly challenging and oftentimes confusing, and although I was not able to achieve as much as I hoped for, I learned an incredible amount not just about memory and C, but about a debugging process I had little to no exposure to. I found the program broken but practical, and it was concise enough to where I could eventually analyze it not for its parts but as a program in its entirety.
